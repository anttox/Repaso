1.Ejecutar el programa con los flags: -l 5:100,5:100
python3 process-run.py -l 5:CPU,5:CPU

Estos flags especifican dos procesos, cada uno con 5 instrucciones de uso de la CPU.
Pregunta: ¿Cuál debería ser la utilización de la CPU (es decir, el porcentaje de tiempo en que la CPU está en uso)? ¿Por qué lo sabes? Usa los flags -c y -p para ver si tenías razón.
Rspt:La CPU está en uso todo el tiempo, ya que ambos procesos están utilizando la CPU continuamente. La utilización de la CPU debería ser del 100%.

2.Ejecutar el programa con los flags: ./process-run.py -l 4:100,1:0
python3 process-run.py -l 4:CPU,1:IO

Estos flags especifican un proceso con 4 instrucciones de uso de la CPU y otro que emite una solicitud de E/S y espera a que se complete.
Pregunta: ¿Cuánto tiempo tarda en completarse ambos procesos? Usa los flags -c y -p para comprobar si tenías razón.
Rspt:El primer proceso toma 4 unidades de tiempo para completarse (4 instrucciones de CPU). El segundo proceso emite una solicitud de E/S y espera, lo que usualmente se considera como 1 unidad de tiempo para la solicitud y espera de E/S. En total, 5 unidades de tiempo.

3.Cambiar el orden de los procesos: -l 1:0,4:100
python3 process-run.py -l 1:IO,4:CPU

Pregunta: ¿Qué sucede ahora? ¿Importa el orden? ¿Por qué? Usa los flags -c y -p para comprobar si tenías razón.
Rspt:El orden no debería importar en este caso porque la primera instrucción de E/S del primer proceso todavía lleva una unidad de tiempo, seguida por las 4 unidades de tiempo del proceso de la CPU. Así que todavía debería tomar 5 unidades de tiempo para completarse.

4.Explorar el flag -S con SWITCH ON END
python3 process-run.py -l 1:IO,4:CPU -S SWITCH ON END

Pregunta: ¿Qué sucede cuando ejecutas los siguientes procesos (-l 1:0,4:100 -c -S SWITCH ON END)?
Rspt:Cuando un proceso está haciendo E/S, el sistema no cambiará a otro proceso hasta que el proceso actual haya terminado. Esto puede resultar en una utilización de la CPU menos eficiente.

5.Ejecutar los mismos procesos con SWITCH ON IO
python3 process-run.py -l 1:IO,4:CPU -S SWITCH ON IO

Pregunta: ¿Qué sucede ahora? Usa los flags -c y -p para confirmar que estás en lo correcto.
Rspt:El sistema cambiará a otro proceso cuando uno esté esperando E/S, lo que debería resultar en una utilización de la CPU más eficiente.

6.Ejecutar procesos con IO RUN LATER
python3 process-run.py -l 3:IO,5:CPU,5:CPU,5:CPU -S SWITCH ON IO -I IO RUN LATER

Pregunta: ¿Qué sucede cuando ejecutas esta combinación de procesos? (./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH ON IO -c -p -I IO RUN LATER)
Rspt:Cuando una E/S completa, el proceso que la emitió no necesariamente se ejecuta de inmediato, lo que puede resultar en una utilización menos eficiente de los recursos del sistema.

7.Ejecutar procesos con IO RUN IMMEDIATE
python3 process-run.py -l 3:IO,5:CPU,5:CPU,5:CPU -S SWITCH ON IO -I IO RUN IMMEDIATE

Pregunta: ¿Cómo difiere este comportamiento? ¿Por qué podría ser una buena idea ejecutar nuevamente un proceso que acaba de completar una E/S?
Rspt:Cuando una E/S completa, el proceso que la emitió se ejecuta de inmediato, lo que puede resultar en una mayor eficiencia si el proceso necesita hacer más trabajo después de la E/S.

8.Ejecutar procesos aleatorios
python3 process-run.py -s 1 -l 3:50,3:50
python3 process-run.py -s 2 -l 3:50,3:50
python3 process-run.py -s 3 -l 3:50,3:50

Pregunta: ¿Qué sucede cuando usas los flags -I IO RUN IMMEDIATE versus -I IO RUN LATER? ¿Qué sucede cuando usas los flags -S SWITCH ON IO versus -S SWITCH ON END?
Rspt:La combinación de estos flags afectará cómo el sistema planifica los procesos y cómo se utiliza la CPU y la E/S. -I IO RUN IMMEDIATE resultará en una respuesta más rápida después de completar la E/S, mientras que -I IO RUN LATER podría resultar en una utilización más eficiente del CPU si hay otros procesos esperando. -S SWITCH ON IO tiende a ser más eficiente en términos de utilización de la CPU en comparación con -S SWITCH ON END.
